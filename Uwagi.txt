1. FivetranClient
1.1. Fetchers
1.1.1. BaseFetcher
null

1.1.2. NonPaginatedFetcher
FetchAsync
0. FetchPageAsync z PaginatedFetcher
a. obsługa wyjątku
b. obsługa wyjątku

1.1.3. PaginatedFetcher
a. Uwaga PageSize zadeklarowany jako ushort, a wykorzystywany tylko jako string.
b. obsługa wyjątku
c. obsługa wyjątku
d. Czy nie lepiej zakończyć szybiciej tą metodę. Jeśli currentPage będzie null, żadna sensowan operacja nie zostanie wykonana. Pytanie tylko czy zwrócić yield czy excepion.


1.2. Infrastructure
1.2.1. FivetranHttpClient
a. Możliwe iż w tym przypadku niekonieczne, wyciągnięceie wartości za hardkodowanych do zmiennych const, utworzenie wyciągnięcie statycznych wartości 
b. Jeśli domyśla nazwa klienta nie odnosi się do niczego konkretnego, zalecam zmianę na powiazaną z klasą na przykąłd "FivetranHttpClient"
c. Metoda CalculateToekn, prawdopobnie powinna być private.

1.2.2. TtlDictionary
a. Zalecane dodanie do asynchroniczną metodą, do lepszej współpracy z handlerem. 
b. brak sprawdzenia poprawnej odpowiedzi "response"
c. brak sprawdzenia nie null/pustego "content"

1.3. Models
1.3.1. Schema
a. Czy nie lepiej ustwić domyślną wartość na false dla "bool? Enabled". Chyba że zaplanowane jest sprawdzanie nul reference.

1.4 HttpRequestHandler
a. Funkcja SemaphoreSlim() w konstruktorze, jako pierwszy argument powinna mieć wartość większą niż 0 lub użyć .Release() przed jakimkolwiek .Wait().
b. Task _GetAsync, dodanie bloku try/finally oraz zastąpienie rekurencji pętlą by uniknąć problemów z ilością wywołań WaitAsync() oraz Release().
c. Możnaby dodać limit ponownych prób/zapytań, w poprzedniej wersji jak i aktualnej, zapytania będą wysyłane aż do otrzymania odpowiedzi.
!!!d. Task GetAsync, użycie właściwości .Result może spowodować zablokowanie wątku, co w połączeniu z metodą _GetAsync, która może się wykonywa w nieskońćzonej pętli spowoduje zablkowanie wątku.


1.5 RestApiManager
Może jest to stylistyczna kwestia ale zmienił bym sposób przypisania wartości w konstruktorze dla "private RestApiManager"

2. Import
2.1. FivetranConnectionSupport.cs

2.1.1. public object? GetConnectionDetailsForSelection()
a.b. Jeśli klucz api nie może być pustym polem/zawierać białe znaki, zastosować zamiast oryginału "public object? GetConnectionDetailsForSelection_AB()"
Dodatkowo, rozwarzyć bardziej szczegółowe Exception()

2.1.2. public object GetConnection(object? connectionDetails, string? selectedToImport)
a. Sprawdzenie czy wartość jest nullem przed tworzeniem obiektów, trochę szybsze.

2.1.3. public void CloseConnection(object? connection)
a. Sugestia zmiany, jeśli funkcja ma tylko sprzątać i nic więcej niezalenie od typu wejściowego argumentu. Zastąpić oryginał modyfikacją "public void CloseConnection_AB(IDisposable connection)"


2.1.4. public string SelectToImport(object? connectionDetails)
a. linijka 64, utworzenie zmiennej by nie wywoływać raz .Any(), a następnym razem .Count()
b. linijka 68, po co sklejać pusty string z pełnym, zamist od razu zadeklarować. Dodatkowo, dla większej ilości grup lepiej zastosować StringBuilder
c. Można by pominąć w warunku sprawdzanie "string.IsNullOrWhiteSpace(input)" gdyż TryParse() też to sprawdzi. Chyba że jest to celowe podkreślenie dal czytelności kodu. 
Dodatkowo, możnaby dać więcej specyficznych Exception dla każdego argumentu by dokąłdniej obsłużyć błąd.
Dodatkowo, sprawdzić czy warunki występują od najczęściej występującego 

2.1.5. public void RunImport(object? connection)
a. Zastosowanie StringBuilder(). Jako że jest zastosowany na końcu 
b. Uwaga, korzystonie z Async() metody oraz .Result

2.2. RestApiManagerWrapper.cs
a. Zastanowić się nad pełną implementacją Disposable Pattern.
